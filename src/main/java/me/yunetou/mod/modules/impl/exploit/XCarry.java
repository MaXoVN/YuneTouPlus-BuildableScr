package me.yunetou.mod.modules.impl.exploit;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import me.yunetou.api.events.impl.ClientEvent;
import me.yunetou.api.events.impl.PacketEvent;
import me.yunetou.api.util.math.ReflectionUtil;
import me.yunetou.api.util.world.InventoryUtil;
import me.yunetou.mod.gui.screen.Gui;
import me.yunetou.mod.modules.Category;
import me.yunetou.mod.modules.Module;
import me.yunetou.mod.modules.settings.Bind;
import me.yunetou.mod.modules.settings.Setting;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.gui.inventory.GuiInventory;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.Slot;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketCloseWindow;
import net.minecraftforge.client.event.GuiOpenEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.InputEvent;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;

public class XCarry
        extends Module {
    public static XCarry INSTANCE = new XCarry();
    private final Setting<Boolean> simpleMode = this.add(new Setting<>("Simple", false));
    private final Setting<Bind> autoDuel = this.add(new Setting<>("AutoDuel", new Bind(-1)));
    private final Setting<Integer> obbySlot = this.add(new Setting<>("ObbySlot", 2, 1, 9, v -> this.autoDuel.getValue().getKey() != -1));
    private final Setting<Integer> slot1 = this.add(new Setting<>("Slot1", 22, 9, 44, v -> this.autoDuel.getValue().getKey() != -1));
    private final Setting<Integer> slot2 = this.add(new Setting<>("Slot2", 23, 9, 44, v -> this.autoDuel.getValue().getKey() != -1));
    private final Setting<Integer> slot3 = this.add(new Setting<>("Slot3", 24, 9, 44, v -> this.autoDuel.getValue().getKey() != -1));
    private final Setting<Integer> tasks = this.add(new Setting<>("Actions", 3, 1, 12, v -> this.autoDuel.getValue().getKey() != -1));
    private final Setting<Boolean> shiftClicker = this.add(new Setting<>("ShiftClick", false).setParent());
    private final Setting<Boolean> withShift = this.add(new Setting<>("WithShift", true, v -> this.shiftClicker.isOpen()));
    private final Setting<Bind> keyBind = this.add(new Setting<>("ShiftBind", new Bind(-1), v -> this.shiftClicker.isOpen()));
    private final AtomicBoolean shouldCloseGui = new AtomicBoolean(false);
    private final Queue<InventoryUtil.QueuedTask> queuedTaskList = new ConcurrentLinkedQueue<>();
    private GuiInventory openedGui;
    private boolean guiCloseGuard;
    private boolean autoDuelOn;
    private boolean obbySlotDone;
    private boolean slot1done;
    private boolean slot2done;
    private boolean slot3done;
    private List<Integer> doneSlots = new ArrayList<>();

    public XCarry() {
        super("XCarry", "Uses the crafting inventory for storage", Category.EXPLOIT);
        INSTANCE = this;
    }

    @Override
    public void onDisable() {
        if (!XCarry.fullNullCheck()) {
            if (!this.simpleMode.getValue()) {
                this.closeGui();
                this.close();
            } else {
                XCarry.mc.player.connection.sendPacket(new CPacketCloseWindow(XCarry.mc.player.inventoryContainer.windowId));
            }
        }
    }

    @Override
    public void onLogout() {
        this.onDisable();
    }

    @Override
    public void onUpdate() {
        if (this.shiftClicker.getValue() && XCarry.mc.currentScreen instanceof GuiInventory) {
            Slot slot;
            boolean ourBind;
            boolean bl = ourBind = this.keyBind.getValue().getKey() != -1 && Keyboard.isKeyDown(this.keyBind.getValue().getKey()) && !Keyboard.isKeyDown(42);
            if ((Keyboard.isKeyDown(42) && this.withShift.getValue() || ourBind) && Mouse.isButtonDown(0) && (slot = ((GuiInventory)XCarry.mc.currentScreen).getSlotUnderMouse()) != null && InventoryUtil.getEmptyXCarry() != -1) {
                int slotNumber = slot.slotNumber;
                if (slotNumber > 4 && ourBind) {
                    this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                    this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                } else if (slotNumber > 4 && this.withShift.getValue()) {
                    boolean isHotBarFull = true;
                    boolean isInvFull = true;
                    for (int i : InventoryUtil.findEmptySlots(false)) {
                        if (i > 4 && i < 36) {
                            isInvFull = false;
                            continue;
                        }
                        if (i <= 35 || i >= 45) continue;
                        isHotBarFull = false;
                    }
                    if (slotNumber > 35 && slotNumber < 45) {
                        if (isInvFull) {
                            this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                            this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                        }
                    } else if (isHotBarFull) {
                        this.queuedTaskList.add(new InventoryUtil.QueuedTask(slotNumber));
                        this.queuedTaskList.add(new InventoryUtil.QueuedTask(InventoryUtil.getEmptyXCarry()));
                    }
                }
            }
        }
        if (this.autoDuelOn) {
            this.doneSlots = new ArrayList<>();
            if (InventoryUtil.getEmptyXCarry() == -1 || this.obbySlotDone && this.slot1done && this.slot2done && this.slot3done) {
                this.autoDuelOn = false;
            }
            if (this.autoDuelOn) {
                if (!this.obbySlotDone && !XCarry.mc.player.inventory.getStackInSlot(this.obbySlot.getValue() - 1).isEmpty) {
                    this.addTasks(36 + this.obbySlot.getValue() - 1);
                }
                this.obbySlotDone = true;
                if (!this.slot1done && !XCarry.mc.player.inventoryContainer.inventorySlots.get(this.slot1.getValue()).getStack().isEmpty) {
                    this.addTasks(this.slot1.getValue());
                }
                this.slot1done = true;
                if (!this.slot2done && !XCarry.mc.player.inventoryContainer.inventorySlots.get(this.slot2.getValue()).getStack().isEmpty) {
                    this.addTasks(this.slot2.getValue());
                }
                this.slot2done = true;
                if (!this.slot3done && !XCarry.mc.player.inventoryContainer.inventorySlots.get(this.slot3.getValue()).getStack().isEmpty) {
                    this.addTasks(this.slot3.getValue());
                }
                this.slot3done = true;
            }
        } else {
            this.obbySlotDone = false;
            this.slot1done = false;
            this.slot2done = false;
            this.slot3done = false;
        }
        if (!this.queuedTaskList.isEmpty()) {
            for (int i = 0; i < this.tasks.getValue(); ++i) {
                InventoryUtil.QueuedTask queuedTask = this.queuedTaskList.poll();
                if (queuedTask == null) continue;
                queuedTask.run();
            }
        }
    }

    @SubscribeEvent(priority=EventPriority.LOWEST)
    public void onGuiOpen(GuiOpenEvent event) {
        if (XCarry.fullNullCheck()) {
            return;
        }
        if (!this.simpleMode.getValue()) {
            if (this.guiCloseGuard) {
                event.setCanceled(true);
            } else if (event.getGui() instanceof GuiInventory) {
                this.openedGui = this.createGuiWrapper((GuiInventory)event.getGui());
                event.setGui(this.openedGui);
                this.shouldCloseGui.set(false);
            }
        }
    }

    @SubscribeEvent
    public void onGuiClose(PacketEvent.Send event) {
        if (XCarry.fullNullCheck()) {
            return;
        }
        if (this.simpleMode.getValue() && event.getPacket() instanceof CPacketCloseWindow) {
            CPacketCloseWindow packet = event.getPacket();
            if (packet.windowId == XCarry.mc.player.inventoryContainer.windowId) {
                event.setCanceled(true);
            }
        }
    }

    @SubscribeEvent
    public void onSettingChange(ClientEvent event) {
        if (XCarry.fullNullCheck()) {
            return;
        }
        if (event.getStage() == 2 && event.getSetting() != null && event.getSetting().getMod() != null && event.getSetting().getMod().equals(this)) {
            Setting setting = event.getSetting();
            String settingname = event.getSetting().getName();
            if (setting.equals(this.simpleMode) && setting.getPlannedValue() != setting.getValue()) {
                this.disable();
            } else if (settingname.equalsIgnoreCase("Store")) {
                event.setCanceled(true);
                this.autoDuelOn = !this.autoDuelOn;
                this.sendMessage("<XCarry> \u00a7aAutostoring...");
            }
        }
    }

    @SubscribeEvent
    public void onKeyInput(InputEvent.KeyInputEvent event) {
        if (XCarry.fullNullCheck()) {
            return;
        }
        if (Keyboard.getEventKeyState() && !(XCarry.mc.currentScreen instanceof Gui) && this.autoDuel.getValue().getKey() == Keyboard.getEventKey()) {
            this.autoDuelOn = !this.autoDuelOn;
            this.sendMessage("<XCarry> \u00a7aAutostoring...");
        }
    }

    private void addTasks(int slot) {
        if (InventoryUtil.getEmptyXCarry() != -1) {
            int xcarrySlot = InventoryUtil.getEmptyXCarry();
            if (!(!this.doneSlots.contains(xcarrySlot) && InventoryUtil.isSlotEmpty(xcarrySlot) || !this.doneSlots.contains(++xcarrySlot) && InventoryUtil.isSlotEmpty(xcarrySlot) || !this.doneSlots.contains(++xcarrySlot) && InventoryUtil.isSlotEmpty(xcarrySlot) || !this.doneSlots.contains(++xcarrySlot) && InventoryUtil.isSlotEmpty(xcarrySlot))) {
                return;
            }
            if (xcarrySlot > 4) {
                return;
            }
            this.doneSlots.add(xcarrySlot);
            this.queuedTaskList.add(new InventoryUtil.QueuedTask(slot));
            this.queuedTaskList.add(new InventoryUtil.QueuedTask(xcarrySlot));
            this.queuedTaskList.add(new InventoryUtil.QueuedTask());
        }
    }

    private void close() {
        this.openedGui = null;
        this.shouldCloseGui.set(false);
        this.guiCloseGuard = false;
    }

    private void closeGui() {
        if (this.shouldCloseGui.compareAndSet(true, false) && !XCarry.fullNullCheck()) {
            this.guiCloseGuard = true;
            if (XCarry.mc.currentScreen != null) {
                XCarry.mc.player.closeScreen();
            }
            if (this.openedGui != null) {
                this.openedGui.onGuiClosed();
                this.openedGui = null;
            }
            this.guiCloseGuard = false;
        }
    }

    private GuiInventory createGuiWrapper(GuiInventory gui) {
        try {
            GuiInventoryWrapper wrapper = new GuiInventoryWrapper();
            ReflectionUtil.copyOf(gui, wrapper);
            return wrapper;
        }
        catch (IllegalAccessException | NoSuchFieldException e) {
            e.printStackTrace();
            return null;
        }
    }

    private class GuiInventoryWrapper
            extends GuiInventory {
        GuiInventoryWrapper() {
            super(XCarry.mc.player);
        }

        protected void keyTyped(char typedChar, int keyCode) throws IOException {
            if (XCarry.this.isOn() && (keyCode == 1 || this.mc.gameSettings.keyBindInventory.isActiveAndMatches(keyCode))) {
                XCarry.this.shouldCloseGui.set(true);
                this.mc.displayGuiScreen(null);
            } else {
                super.keyTyped(typedChar, keyCode);
            }
        }

        public void onGuiClosed() {
            if (XCarry.this.guiCloseGuard || !XCarry.this.isOn()) {
                super.onGuiClosed();
            }
        }
    }
}
