package me.yunetou.mod.modules.impl.exploit;

import java.util.Random;
import me.yunetou.api.events.impl.PacketEvent;

import me.yunetou.api.util.math.Timer;
import me.yunetou.mod.modules.Category;
import me.yunetou.mod.modules.Module;
import me.yunetou.mod.modules.settings.Setting;
import net.minecraft.entity.Entity;
import net.minecraft.init.Items;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketPlayerTryUseItem;
import net.minecraft.util.EnumHand;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class SuperThrow
        extends Module {
    public static final Timer delayTimer = new Timer();
    public final Setting<Boolean> pearls = this.add(new Setting<>("EPearls", true));
    public final Setting<Boolean> xp = this.add(new Setting<>("XP", true));
    public final Setting<Boolean> eggs = this.add(new Setting<>("Eggs", true));
    public final Setting<Boolean> potions = this.add(new Setting<>("SplashPotions", true));
    public final Setting<Boolean> snowballs = this.add(new Setting<>("Snowballs", true));
    public final Setting<Boolean> rotation = this.add(new Setting<>("Rotation", false));
    public final Setting<ModeEn> Mode = this.add(new Setting<>("Mode", ModeEn.Maximum));
    public final Setting<Float> factor = this.add(new Setting<>("Factor", 1.0f, 1.0f, 20.0f));
    public final Setting<exploitEn> exploit = this.add(new Setting<>("Exploit", exploitEn.Strong));
    public final Setting<Boolean> minimize = this.add(new Setting<>("Minimize", false));
    public final Setting<Float> delay = this.add(new Setting<>("Delay", 5.0f, 0.0f, 10.0f));
    private final Random rnd = new Random();

    public SuperThrow() {
        super("SuperThrow", "exploit", Category.EXPLOIT);
    }

    @SubscribeEvent
    protected void onPacketSend(PacketEvent.Send event) {
        if (SuperThrow.fullNullCheck() || !delayTimer.passedMs((long)(this.delay.getValue() * 1000.0f))) {
            return;
        }
        if (event.getPacket() instanceof CPacketPlayerDigging && ((CPacketPlayerDigging)event.getPacket()).getAction() == CPacketPlayerDigging.Action.RELEASE_USE_ITEM) {
            SuperThrow.mc.player.getActiveItemStack().getItem();
        }
        if (event.getPacket() instanceof CPacketPlayerTryUseItem && ((CPacketPlayerTryUseItem)event.getPacket()).getHand() == EnumHand.MAIN_HAND && (SuperThrow.mc.player.getHeldItemMainhand().getItem() == Items.ENDER_PEARL && this.pearls.getValue() || SuperThrow.mc.player.getHeldItemMainhand().getItem() == Items.EXPERIENCE_BOTTLE && this.xp.getValue() || SuperThrow.mc.player.getHeldItemMainhand().getItem() == Items.EGG && this.eggs.getValue() || SuperThrow.mc.player.getHeldItemMainhand().getItem() == Items.SPLASH_POTION && this.potions.getValue() || SuperThrow.mc.player.getHeldItemMainhand().getItem() == Items.SNOWBALL && this.snowballs.getValue())) {
            int i;
            SuperThrow.mc.player.connection.sendPacket(new CPacketEntityAction(SuperThrow.mc.player, CPacketEntityAction.Action.START_SPRINTING));
            double[] strict_direction = new double[]{100.0 * -Math.sin(Math.toRadians(SuperThrow.mc.player.rotationYaw)), 100.0 * Math.cos(Math.toRadians(SuperThrow.mc.player.rotationYaw))};
            if (this.exploit.getValue() == exploitEn.Fast) {
                for (i = 0; i < this.getRuns(); ++i) {
                    this.spoof(SuperThrow.mc.player.posX, this.minimize.getValue() ? SuperThrow.mc.player.posY : SuperThrow.mc.player.posY - 1.0E-10, SuperThrow.mc.player.posZ, true);
                    this.spoof(SuperThrow.mc.player.posX, SuperThrow.mc.player.posY + 1.0E-10, SuperThrow.mc.player.posZ, false);
                }
            }
            if (this.exploit.getValue() == exploitEn.Strong) {
                for (i = 0; i < this.getRuns(); ++i) {
                    this.spoof(SuperThrow.mc.player.posX, SuperThrow.mc.player.posY + 1.0E-10, SuperThrow.mc.player.posZ, false);
                    this.spoof(SuperThrow.mc.player.posX, this.minimize.getValue() ? SuperThrow.mc.player.posY : SuperThrow.mc.player.posY - 1.0E-10, SuperThrow.mc.player.posZ, true);
                }
            }
            if (this.exploit.getValue() == exploitEn.Phobos) {
                for (i = 0; i < this.getRuns(); ++i) {
                    this.spoof(SuperThrow.mc.player.posX, SuperThrow.mc.player.posY + 1.3E-13, SuperThrow.mc.player.posZ, true);
                    this.spoof(SuperThrow.mc.player.posX, SuperThrow.mc.player.posY + 2.7E-13, SuperThrow.mc.player.posZ, false);
                }
            }
            if (this.exploit.getValue() == exploitEn.Strict) {
                for (i = 0; i < this.getRuns(); ++i) {
                    if (this.rnd.nextBoolean()) {
                        this.spoof(SuperThrow.mc.player.posX - strict_direction[0], SuperThrow.mc.player.posY, SuperThrow.mc.player.posZ - strict_direction[1], false);
                        continue;
                    }
                    this.spoof(SuperThrow.mc.player.posX + strict_direction[0], SuperThrow.mc.player.posY, SuperThrow.mc.player.posZ + strict_direction[1], true);
                }
            }
            delayTimer.reset();
        }
    }

    private void spoof(double x, double y, double z, boolean ground) {
        if (this.rotation.getValue()) {
            SuperThrow.mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(x, y, z, SuperThrow.mc.player.rotationYaw, SuperThrow.mc.player.rotationPitch, ground));
        } else {
            SuperThrow.mc.player.connection.sendPacket(new CPacketPlayer.Position(x, y, z, ground));
        }
    }

    private int getRuns() {
        if (this.Mode.getValue() == ModeEn.Factorised) {
            return 10 + (int)(this.factor.getValue() - 1.0f);
        }
        if (this.Mode.getValue() == ModeEn.Normal) {
            return (int)Math.floor(this.factor.getValue());
        }
        if (this.Mode.getValue() == ModeEn.Maximum) {
            return (int)(30.0f * this.factor.getValue());
        }
        return 1;
    }

    private static enum ModeEn {
        Normal,
        Maximum,
        Factorised

    }

    private static enum exploitEn {
        Strong,
        Fast,
        Strict,
        Phobos

    }
}
