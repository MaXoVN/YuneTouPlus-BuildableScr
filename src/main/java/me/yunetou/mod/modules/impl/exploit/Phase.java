package me.yunetou.mod.modules.impl.exploit;

import me.yunetou.api.managers.impl.SneakManager;
import me.yunetou.api.util.entity.EntityUtil;
import me.yunetou.api.util.interact.BlockUtil;
import me.yunetou.mod.modules.Category;
import me.yunetou.mod.modules.Module;
import me.yunetou.mod.modules.settings.Setting;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.entity.Entity;
import net.minecraft.init.Blocks;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;

public class Phase
        extends Module {
    public static Phase INSTANCE = new Phase();
    private final Setting<Mode> mode = this.add(new Setting<>("Mode", Mode.Stuck));
    private final Setting<Boolean> onlyBurrow = this.add(new Setting<>("OnlyBurrow", true, v -> this.mode.getValue() == Mode.Skip));
    private final Setting<Boolean> onBurrow = this.add(new Setting<>("OnBurrow", false, v -> !this.onlyBurrow.getValue() || this.mode.getValue() == Mode.Stuck));
    private final Setting<Double> offset2 = this.add(new Setting<>("Speed", 0.6, 0.1, 1.0, v -> this.mode.getValue() == Mode.Skip));
    private final Setting<Integer> delay = this.add(new Setting<>("Delay", 1, 0, 20, v -> this.mode.getValue() == Mode.Skip));
    private final Setting<Integer> offset = this.add(new Setting<>("Offset", 1, 0, 10, v -> this.mode.getValue() == Mode.Stuck));
    private final Setting<Boolean> toggle = this.add(new Setting<>("AutoToggle", false, v -> this.mode.getValue() == Mode.Stuck));
    private int tickTimer;

    public Phase() {
        super("Phase", "esu dog", Category.EXPLOIT);
        INSTANCE = this;
    }

    public static double getDirection() {
        float rotationYaw = Phase.mc.player.rotationYaw;
        if (Phase.mc.player.moveVertical < 0.0f) {
            rotationYaw += 180.0f;
        }
        float forward = 1.0f;
        if (Phase.mc.player.moveVertical < 0.0f) {
            forward = -0.5f;
        } else if (Phase.mc.player.moveVertical > 0.0f) {
            forward = 0.5f;
        }
        if (Phase.mc.player.moveStrafing > 0.0f) {
            rotationYaw -= 90.0f * forward;
        }
        if (Phase.mc.player.moveStrafing < 0.0f) {
            rotationYaw += 90.0f * forward;
        }
        return Math.toRadians(rotationYaw);
    }

    public static boolean collideBlockIntersects(AxisAlignedBB axisAlignedBB, Function1<? super Block, Boolean> collide) {
        WorldClient world = Phase.mc.world;
        int i = (int)Math.floor(Phase.mc.player.getEntityBoundingBox().minX);
        while (i < (int)Math.floor(Phase.mc.player.getEntityBoundingBox().maxX) + 1) {
            int x = i++;
            int j = (int)Math.floor(Phase.mc.player.getEntityBoundingBox().minZ);
            while (j < (int)Math.floor(Phase.mc.player.getEntityBoundingBox().maxZ) + 1) {
                AxisAlignedBB axisAlignedBB3;
                AxisAlignedBB axisAlignedBB2;
                IBlockState blockState;
                Block block;
                Block block2;
                int z = j++;
                BlockPos blockPos = new BlockPos(x, axisAlignedBB.minY, z);
                WorldClient world2 = Phase.mc.world;
                if (world2 == null) {
                    block2 = null;
                } else {
                    IBlockState getBlockState = world2.getBlockState(blockPos);
                    block2 = getBlockState.getBlock();
                }
                if (!collide.invoke(block = block2)) continue;
                WorldClient world3 = Phase.mc.world;
                IBlockState iBlockState = blockState = world3 == null ? null : world3.getBlockState(blockPos);
                if (blockState == null) {
                    axisAlignedBB2 = null;
                } else {
                    AxisAlignedBB axisAlignedBB4 = axisAlignedBB2 = block == null ? null : block.getSelectedBoundingBox(blockState, world, blockPos);
                }
                if ((axisAlignedBB3 = axisAlignedBB2) == null || !Phase.mc.player.getEntityBoundingBox().intersects(axisAlignedBB3)) continue;
                return true;
            }
        }
        return false;
    }

    @Override
    public void onTick() {
        if (this.mode.getValue() == Mode.Stuck) {
            double x = Math.abs(Phase.mc.player.posX) - Math.floor(Math.abs(Phase.mc.player.posX));
            double z = Math.abs(Phase.mc.player.posZ) - Math.floor(Math.abs(Phase.mc.player.posZ));
            if (x == 0.7 || x == 0.3 || z == 0.7 || z == 0.3 || !this.onBurrow.getValue() && !Phase.mc.world.getBlockState(BlockUtil.getFlooredPosition(Phase.mc.player)).getBlock().equals(Blocks.AIR)) {
                return;
            }
            Vec3d playerVec = Phase.mc.player.getPositionVector();
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(playerVec.add(new Vec3d(0.3 + (double) this.offset.getValue() / 100.0, 0.2, 0.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX + (double) this.offset.getValue() / 100.0, Phase.mc.player.posY, Phase.mc.player.posZ);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(playerVec.add(new Vec3d(-0.3 - (double) this.offset.getValue() / 100.0, 0.2, 0.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX - (double) this.offset.getValue() / 100.0, Phase.mc.player.posY, Phase.mc.player.posZ);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(playerVec.add(new Vec3d(0.0, 0.2, 0.3 + (double) this.offset.getValue() / 100.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX, Phase.mc.player.posY, Phase.mc.player.posZ + (double) this.offset.getValue() / 100.0);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(playerVec.add(new Vec3d(0.0, 0.2, -0.3 - (double) this.offset.getValue() / 100.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX, Phase.mc.player.posY, Phase.mc.player.posZ - (double) this.offset.getValue() / 100.0);
                if (this.toggle.getValue()) {
                    this.disable();
                }
            }
        } else {
            ++this.tickTimer;
            boolean isInsideBlock = Phase.collideBlockIntersects(Phase.mc.player.getEntityBoundingBox(), block -> block != Blocks.AIR);
            if (!Phase.mc.player.onGround || this.tickTimer < this.delay.getValue() || !Phase.mc.player.collidedHorizontally) {
                return;
            }
            if (isInsideBlock && !SneakManager.isSneaking && !this.onBurrow.getValue() && !this.onlyBurrow.getValue()) {
                return;
            }
            if (this.onlyBurrow.getValue() && !isInsideBlock && Phase.mc.world.isAirBlock(EntityUtil.getPlayerPos().up()) && Phase.mc.world.getBlockState(EntityUtil.getPlayerPos()).getBlock() != Blocks.PISTON_HEAD) {
                return;
            }
            double direction = Phase.getDirection();
            double posX = -Math.sin(direction) * this.offset2.getValue();
            double posZ = Math.cos(direction) * this.offset2.getValue();
            for (int i = 0; i < 3; ++i) {
                Phase.mc.player.connection.sendPacket(new CPacketPlayer.Position(Phase.mc.player.posX, Phase.mc.player.posY + 0.06, Phase.mc.player.posZ, true));
                Phase.mc.player.connection.sendPacket(new CPacketPlayer.Position(Phase.mc.player.posX + posX * (double)i, Phase.mc.player.posY, Phase.mc.player.posZ + posZ * (double)i, true));
            }
            Phase.mc.player.setEntityBoundingBox(Phase.mc.player.getEntityBoundingBox().offset(posX, 0.0, posZ));
            Phase.mc.player.setPositionAndUpdate(Phase.mc.player.posX + posX, Phase.mc.player.posY, Phase.mc.player.posZ + posZ);
            this.tickTimer = 0;
        }
    }

    public static interface Function {
    }

    public static interface Function1<P1, R>
            extends Function {
        public R invoke(P1 var1);
    }

    public static enum Mode {
        Stuck,
        Skip

    }
}